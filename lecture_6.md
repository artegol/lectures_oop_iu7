# Лекция №6 по ООП

## Темы, рассмотренные на лекции

Создание объектов в С++.   Явный и неявный вызов конструкторов. Делегирующие и унаследованные конструкторы. Наследование в С++. Построение иерархии классов. Выделение общей части группы классов. Расщепление классов. Множественное наследование. Прямая и косвенная базы. Виртуальное наследование. Понятие доминирования. Проблемы множественного наследования. Неоднозначности при множественном наследовании.

## Конструкторы

По умолчанию создается 3 конструктора:

* Конструктор по умолчанию
* Конструктор копирования
* Конструктор переноса

Если хотя бы один из этих трех конструкторов определен, то конструктор по умолчанию не создаётся

Если определили конструктор копирования, конструктор переноса не создается

Если мы определяем глобальный или глобальный статический объекты, то конструктор для них выполняются функции main

После отрабатывают деструкторы

Деструкторы всегда вызываются в обратном порядке порядку создания объектов

Для локальных объектов конструктор вызывается при входе в блок

Если объект тяжелый, то лучше создавать его до входа в цикл

Мы можем явно вызывать конструктор. Приведение типа - это явный вызов конструктора

Деструктор вызывается, когда отпадает необходимость в использовании объекта. Каждый компилятор воспринимает это по своему. Где-то при выходе из блока, где то после выполнения выражения

Конструктор может вызываться неявно. При передаче в метод или ф-ию по значению или при возврате.

Для того, чтобы нельзя было вызвать конструктор неявно перед конструктором копирования и перед конструкторами, принимающими один параметр ставим `explicit`

Основной механизм вызова конструктора переноса - неявный при возврате из метода, из функции объекта.

К вызову конструктора так же приводит оператор `new`

Конструктор не может быть статическим, константным, виртуальным и изменяемым

Деструктор не может быть статическим, константным, но может быть виртуальным

## Варианты создания объекта в языке C++

<тип><идентификатор>[список выражений]

`A obj();` - Функция не принимающая параметров, возвращающая A.

### Явный вызов конструктора

<тип><идентификатор>{список параметров}

`A obj{}` - Конструктор вызывается. Все члены, не проиницилизированные в классе обнуляются

`A obj` - тоже вызывется конструктор, но члены не будут обнулены

`new <тип>{список параметров}`

`<тип><идентификатор> = <тип>{}`

### Неявный вызов конструктора

<тип><идентификатор> = <выражение>

<тип><идентификатор> = {список параметров}

## Библиотечный класс `initializer_list`

Контейнерный класс - содержит данные какого-то другого типа

Позволяет инициализировать контейнерные классы

```C++
Array::Array(initializer_list<double> lst)
    : count(lst.size())
{
    arr = new double[count];
    size_t i = 0;
    for(auto p = lst.begin(); p != lst.end(); p++)
        arr[i++] = *p;
}
```
Для работы с контейнерными классами в объектно ориентированные языки добавлен цикл for each

Конструкторы и деструкторы не наследуются

```C++
class A
{
public:
    A();
    A(int i, int j);
    A(int i):A(i, 0){}// В одном конструкторе вызываем верхний конструктор
}

class B: public A
{
public:
    B(double d);
    using A::A; //пронаследовали конструктор
}
```

`B obj;` - нельзя написать, конструктор не наследуется, после using можно

В одном конструкторе можно использовать другой конструктор того же самого класса

`A obj{1, 2}` - если нет конструктора с initializer_list то вызовется конструктор с двумя параметрами

## Выделение общей части группы классов.

Если приполагается что класс будет видоизменятся, то для этого класса нужно выделить базовый класс

1) Могут быть две сущности разных классов, но у которых общая схема использования(интерфейс) -> объединяем сущности базовой абстракцией

Указатель на производный класс неявно преобразуется к указателю на базовый. Ссылкой на базовый класс можно захватить любой объект производных классов.

2) Если две абсолютно разные сущности, но они имеют общий метод, должны выполнять декомпозицию

3) Если у двух объектов абсолютно разные сущности, но код некоторых методов повторяется, то выделяем общую сущность

4) Несколько сущностей, но сущности рассматриваются вместе. Желательно на ранних стадиях выделить для них общую базу

## Расщепление классов.

1) Если сущность выполняет несколько ролей, значит расщепляем сущность

2) Если роль одна, но на эту роль возлагается несколько обязанностей, то расщепляем сущность

3) Если у одной сущности есть методы, которые не связаны между собой, то расщепляем сущность

4) Если одна сущность выполняется в разных частях программы, значит расщепляем сущность

## Множественное наследование

Прямая база - класс, от которого мы непосредственно пронаследовались

Косвенная база - база, которая находится где-то в иерархии классов

* Доминирование - функция или функции в производном классе с таким же именем подменяют методы базового класса

До 11 стандарта работало как перегрузка, но это приводило к ошибкам

Можно возвращать методы через `using`

Множественное наследование - на основе каких-то сущностей получаем новую сущность (объеденение интерфейсов в общем случае)

В множественном наследовании есть возможность скакать от одной базы к другой (использовать разные интерфейсы)

Множественное наследование вызывает неоднозначность: в базовых классах могут быть методы с одинаковыми именами или методы с разными уровнями доступа.
Проблема в том, что проверка на перегрузку, уровень доступа или тип проходит после проверки на неоднозначность


## Ромбовидное наследование

```C++
class A{};
class B: virtual public A{};
class C: virtual public A{};
class D: public B, public C;
```

При виртуальном наследовании косвенная база входит один класс

В производном классе мы должны определять конструкторы косвенной базы