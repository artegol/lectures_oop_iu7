# Лекция №7 по ООП

## Темы, разобранные на лекции

Проблемы множественного наследования. Неоднозначности при множественном наследовании. Полиморфизм в С++. Виртуальные методы. Чисто виртуальные методы. Понятие абстрактного класса. Виртуальные и чисто виртуальные деструкторы. Ошибки, возникающие при работе с указателем или ссылкой на базовый класс. Дружественные связи.

## Проблемы множественного наследования.

Множественное наследование - это направленный ациклический граф

1) Проблема неоднозначности: возможно, что в разных базовых классах будут определены методы с одними и теми же именами, или методы с разным уровнем доступа, или методы и данные с одним и тем же именем. Проверка на перегрузку происходит после проверки на неоднозначность.

2) Проблема доминирования: если какой-то метод с таким же именем в НАГе находится ниже, то он подменяет все методы, которые находятся выше.

3) Проблема ромбовидного наследования: при виртуальном наследовании в производном классе мы обязаны определять конструкторы, которые находятся в косвенной базе. Вызываем эти объекты в первую очередь.

Основной подход написания программы - рекурсивный дизайн: добавление производных классов

```C++
class A
{
public:
    void f();
};

class B: public A
{
public:
    void f()
    {
        A::f();
    }
}
```

4) Метод косвенной базы будет выполняться 2 раза. Красивых способов борьбы с этим нет

Мы ограничиваемся множественным наследованием без косвенных баз.
В каком-то месте работаем с интерфейсом одного класса, в другом месте - другого

## Полиморфизм в С++

Полиморфизм - возможность подменить одно на другое используя ссылку/указатель на базовый класс

Если указатель производного класса приводим к указателю на базовый, то будет вызываться метод базовового класса, а хочется на производный...

Идея состоит в том, что выбор того какой метод выполнять мы отдаем на откуп компилятору.

Указатели на методы выносятся в отдельную таблицу. Таблица является общей для всех объектов данного класса. Указатель на таблицк храним в классе. В объекте будет хранится поле-указатель на эту таблицу.

Выбор метода в виртуальной таблице сильно тормозит работу.

Если в классе определяем метод с модификатором `virtual`, то этот класс называем полиморфным. В объекты этого класса будет добавляться указатели на виртуальную таблицу. Если один метод виртуальный, то остальные методы тоже являются виртуальными, чтобы была возможность подменить один объект на другой. Производные от полиморфного класса будут тоже полиморфными

```C++
class A
{
public:
    virtual void f() = 0;
    virtual ~A() = default;
    explicit A(const A&) = 0;
}

class B: public A
{
public:
    void f()
}
```

Класс B будет полиморфным и тогда в ситуации:
```C++
{
    A* p = new B{};
    p->f();
}
```

Вызовется метод класса B, а не А

Смотря только на производный класс мы не можем сказать подменяет ли его метод базовый

В 11 стандарте добавили ключевое слово `override` (подменяет). Проблема в том, что это ключевое слово писать необязательно. Желательно его писать всегда.

Базовые сущности, которые мы будем определять всегда должны быть абстрактными. Методы для абстрактных понятий обычно не реализуются: `virtual void f() = 0` Если мы не реализуем этот метод в производном классе, то он тоже будет вбстрактным

```C++
{
    A* p = new B{};
    p->f();
    delete p; // должен удаляться объект класса В, а удаляется на А

    // ТАК ПИСАТЬ КАТЕГОРИЧЕСКИ НЕЛЬЗЯ!!!
}
```

Если создаём базовую абстракцию, то мы обязаны определить виртуальный деструктор

В иерархии полиморфных классов мы обязаны определять конструктор копирования

Базовый класс задаёт интерфейс

Определим функцию:
```C++
A& index(A* ar, size_t i)
{
    return ar[i];
}
```

Массивы объектов создавать нельзя, а массивы указателей на объекты - можно

## Дружба в С++

Если мы устанавливаем дружбу, то друг имеет доступ ко всем нашим членам

После выполнения метода, члены объекта данного класса должны быть не противоречивы, то есть обеспечить целостность

Дружба является односторонней

### Что может быть другом?

```C++
class C
{
    friend void f(C&);// друг клачча - внешняя функция
    friend void B:g();// друг класса - метод другого класса
    friend class A;// друг класса - класс(все методы этого класса будут иметь доступ к нашему классу - жесткая связка)

    // лучший вариант - друг метод
}
```

Никаких внешних функций!!!

Дружба не наследуется и не транзитивна

Другом класса может быть виртуальный метод, который подменяется в производных классах
