# Лекция № 3 по ООП (Основные идеи ООП)

На прошлой лекции были рассмотрены первые основные понятия ООП - инкапсуляция, наследование (и полиморфизм)

Будем исследовать шаблоны и паттерны проектирования

## Недостатки технологии ООП

* Нужно получить начальную объектную модель

Пока эта модель не будет получена к этапу кодирования переходить смысла нет

* Порог вхождения в технологию ООП высокий

* Код резко разрастается

Принципиально другие размеры программы, значит время написания и время компиляции тоже увеличиваются

* Возникает много мертвого кода

В современных языках эту проблему решили таким образом, что этап компиляции и выполнения объеденяются

Из этого следует плюс, что в серверных приложениях можно не останавливать работу программы и исправлять ошибки на лету

Минусов много, но эта технология позволяет модифицировать программу бесконечно, не создается кода в корзину

## С какими понятиями мы работаем в ООП

* Объект

Конкретная реализация некоторого абстрактного типа которое обладает характеристиками состояния поведения и индивидуальности

Состояние - один из возможных вариантов существования объекта

Поведение - описание объекта в терминах изменения его состояния

Инндивидуальность - отличие от других объектов

На основе возможных состояний объекта мы строим его жизненный цикл (модель состояния объекта). Для описания модели состояния объекта можно использовать модель Мура. Эта модель состоит из множества состояний в которых может находиться объект(из множества событий которые могут приводить к изменению состояния). С каждым состоянием будем связывать действия.

> Что может быть объектом? Все, что угодно, мы их будем создавать по шаблонам.

Категории объектов:

Реальный объект. Объекты, которые присутствуют в физическом мире

Роли. Один физический объект может выполнять несколько ролей. На объект в программе - одна роль.

Инцинденты. Абстракции чего либо случившегося или произошедшего. Проходят через какие-то стадии к заключительному состоянию

Объекты взаимодействия. Объекты, которые получаются из отношений других объектов.

Спецификации. Для стандартов, контроля качества. Эти объекты нас просто о чем-то информируют

Отношения между объектами:

1) Отношение использования

Воздействующие объекты. Объекты воздействуют, но сами никогда не подвержены воздействию от других объектов. Активные объекты.

Важно использовать схему включения, он обеспечивает защиту от окружающего мира.

* Классы

Классы - это множество предметов реального мира, что все предметы в этом мире имеют одни и те же характеристики и имеют общее поведение

Какие отношения вступают в классы?

1) Отношение наследования

Один класс использует другие классы

2) Схема включения.

Класс определяем внутри другого класса

Метаклассы и метаобъекты

* Домены

Домен - отдельный реальный или гепотетический мир населенный отчетливым набором объектов, которые существуют с характерными для домена правилами или линиями поведения.

## Сравнение структуры программы на языке C и C++

### Язык C

В языке Си каждый файл компилируется отдельно

Это неудобно, поскольку нужно объявлять или определять данные в каждом новом файле

Были предложены хэдер файлы

В хэдр файлах распологаем:
Переменные, константы, типы данных

Определять переменные нельзя.

Глобальные переменные избегаем. Не все константы можно объявить в заголовочном файле

В C++ этапы компиляции и сборки разделены, из-за этого возникает много мертвого кода

Для того чтобы получился надежный программный продукт, при разработке языка C++ были введены ссылки

Ссылка - не тип данных

Ссылка - еще одно имя того же самого данного

`int i; int& ai`

`ai = 2;` то же самое, что и `i = 2;`

Под капотом это тот же самый указатель но безопасный (память не выделяется)

Ссылку на локальное данное возвращать нельзя

Никаких звёздочек в коде

Под объект память выделяем динамически, в куче