# Лекция №8 по ООП

## Темы, рассмотренные на лекции

Блоки try и catch. Блоки try и catch методов и конструкторов. Безопасный код относительно исключений. Обертывание исключения в exception_ptr. Перегрузка операторов в С++. Операторы .*, -)*. Правила перегрузки операторов.  Перегрузка операторов =, () и [ ]. Перегрузка операторов -), *. Перегрузка бинарных операторов.

## Обработка исключений в С++

В структурном программировании мы протаскивали ошибку на более высокий уровень до того момента пока функция не сможет ее обработать.

В ООП же мы будем сразу прокидывать ошибку в ту функцию, которая ее обрабатывает

По цепочке вызова методов(стек) переходим туда, где мы сожем обработать эту ошибку

Эта идея очень хороша, но резко разрастается ассемблерный код и время выполнения программы резко увеличивается.

Программист сам решает нужен ли ему механизм прокидывания ошибки или не нужен

Отделяем обработку ошибки от логики задачи. Данные об ошибке: где произошла, когда произошла, что за ошибка. Мы должны ошибку логировать, значит нужны данные, которые привели к ошибке.

При критической ошибке отрабатывают деструкторы объектов.

В языке С++ невозможно вернуться в точку возникновения ошибки

Синтаксис:
```C++
try
{
    ...
    throw<объект>;
}
catch(<тип><идентификатор>)
{
    //происходит проверка совпадения типа
}
```

Если не поймали ошибку на этом уровне, то прокидываем её дальше

Будем использовать механизм который дает возможность красиво ловить ошибки, но старые библиотеки могут генерить ошибки таких типов о которых мы не знаем. Чтобы поймать любую ошибку, используем: `catch(...)`

Не нужно протаскивать ошибку и обработка ошибки выносится отдельно.

Под каждую ситуацию будем создавать свой класс ошибки.(в поликлиннике под каждую нашу болезнь есть врач)

У классов обработки ошибки общее поведение, их нужно объеденить в общуу иерархию.

`std::exaption`
метод `what()`

От этого класса порождаем классы ошибок

Идея: для каждого класса создать свой класс ошибки

В ООП при появлении новой ошибки можем добавлять новые классы

Мы всегда уверены если ошибка выявлялась раньше,то и появление новой ошибки будет поймано

Методы должны следить за целостностью объекта

В 11 стандарте добавили механизм который может любую ошибку обернуть в оболочку и кинуть, когда появитс возможность. Можно обарачивать до тех пор, пока оборачивается.

## `exception_ptr`

Ошибку, которую поймали, оборачиваем в exception_ptr
```C++
exception_ptr getexception()
{
    try
    {
        f();
    }
    catch(...)
    {
        return std::current_exception();
    }
    return nullptr;
}
```

## `noexcept`

Если какие-то методы не кидают исключения, то мы можем эти методы определять с модификатором `noexcept[(<выражение>)]` или `throw(<тип>)`

noexcept или throw - обещание компилятору, что функция не кидает исключения. Если же в функциях где мы пишем это и кидаем исключение, программа начинает валиться. При noexcept вызывается ф-ия terminate (она сворачивает по стеку), при throw же не вызывается. throw с пустыми круглыми скобками нельзя писать. noexcept писать стоит, но обещание нужно выполнять.

Любой деструктор по умолчанию `noexcept`. Генерация исключительной ситуации в деструкторе может вызвать рекурсивный вызов деструктора.

Исключения не летают парами

Конструкторы классов, поражденных от `std::exception`, кидать исключения не должны.

```C++
void f(<параметры>) try
{

}
catch()

<тип>::<тип>(<параметры>)try: <раздел инициализации>
{

}
catch(...)
{

}
```

Мы можем любое исключение поймать, поработать с ним, и кинуть дальше

## Перегрузка операторов

Перегрузка операторов появилась до ООП

Практически все современные ОО языки предоставляют возможность задания своих операций для своих классов

Перегрузка операторов - для существующих операторов создаем свою операцию под свой тип данных. Не меняйтся арность операторов и их приоритет.

Не перегружаются операторы:

* . (доступ к члену или методу класса)

* .* (доступ к члену или методу класса по указателю)

* :: (оператор работы с пространствами имен и работы со статическими методами класса)

* ?: (тернарный оператор не придумали как перегружать)

* sizeof (это метод, его нельзя перегружать)

* typeid (оператор: ты кто?)

## Как перегружаются операторы?

Практически все операторы можно перегружать или как члены объекта или как внешние функции, за исключением таких операторов как: `= -> () []`: они перегружаются только как члены объекта

Унарные операторы перегружаем как члены объекта.

Бинарные операторы (за исключением new и delete) мы должны перегружать как методы объекта, не как методы класса

Комплексное число:
```C++
class Complex
{
    double re, im;
public:
    bool operator == (const Complex& c); (перегрузка оператора сравнения)
}
```

Если мы хотим, чтобы у нас перегружаемые операторы выполнялись коммутативно, то мы определяем их как внешние функции

`<< >>` - стандартный поток ввода-вывода перегружаем, как сдвиг влево и сдвиг вправо (определяем как внешние)

```C++
class Array
{
public:
    Array& operator = (const Array& ar);
    Array& operator = (Array&& ar);
}
```

При вызове виртуальных методов базового класса в конструкторе объект еще не будет создан, а в деструкторе уже будет удален из-за порядка создания и уничтожения объектов

При перегрузке оператора [], мы лишаемся коммутативности (нельзя писать и a[i], и i[a])

Оператор ()